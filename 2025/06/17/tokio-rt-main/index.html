<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="123456789#[tokio::main]async fn main() -&gt; io::Result&lt;()&gt; &#123;    let file &#x3D; OpenOptions::new()        .read(true)        .open(&quot;foo.txt&quot;)        .await?;    Ok(())&#125;  Rust 的 m">
<meta property="og:type" content="article">
<meta property="og:title" content="tokio runtime -- main macro">
<meta property="og:url" content="https://zhaosima.github.io/2025/06/17/tokio-rt-main/">
<meta property="og:site_name" content="WindFlow">
<meta property="og:description" content="123456789#[tokio::main]async fn main() -&gt; io::Result&lt;()&gt; &#123;    let file &#x3D; OpenOptions::new()        .read(true)        .open(&quot;foo.txt&quot;)        .await?;    Ok(())&#125;  Rust 的 m">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-06-17T02:43:46.000Z">
<meta property="article:modified_time" content="2025-06-19T02:08:48.067Z">
<meta property="article:author" content="WindFlow">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>tokio runtime -- main macro</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/null">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2025/06/19/tokio-rt-main2/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/06/17/tokio-rt-spawn/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://zhaosima.github.io/2025/06/17/tokio-rt-main/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&text=tokio runtime -- main macro"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&title=tokio runtime -- main macro"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&is_video=false&description=tokio runtime -- main macro"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=tokio runtime -- main macro&body=Check out this article: https://zhaosima.github.io/2025/06/17/tokio-rt-main/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&title=tokio runtime -- main macro"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&title=tokio runtime -- main macro"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&title=tokio runtime -- main macro"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&title=tokio runtime -- main macro"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&name=tokio runtime -- main macro&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&t=tokio runtime -- main macro"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#tokio-main-%E5%AE%8F"><span class="toc-number">1.</span> <span class="toc-text">tokio::main 宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multi-thread-builder-build"><span class="toc-number">2.</span> <span class="toc-text">multi thread builder build</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#launch"><span class="toc-number">2.1.</span> <span class="toc-text">launch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#worker"><span class="toc-number">2.2.</span> <span class="toc-text">worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#core"><span class="toc-number">2.3.</span> <span class="toc-text">core</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run-worker"><span class="toc-number">2.4.</span> <span class="toc-text">run worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run-core"><span class="toc-number">2.5.</span> <span class="toc-text">run core</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run-task"><span class="toc-number">2.6.</span> <span class="toc-text">run task</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        tokio runtime -- main macro
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">WindFlow</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-06-17T02:43:46.000Z" class="dt-published" itemprop="datePublished">2025-06-17</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">file</span> = OpenOptions::<span class="title function_ invoke__">new</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read</span>(<span class="literal">true</span>)</span><br><span class="line">        .<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo.txt&quot;</span>)</span><br><span class="line">        .<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 的 <code>main</code> 本身不支持 <code>async</code>，那么 <code>tokio::main</code> 做了什么呢？</p>
<h2 id="tokio-main-宏"><a href="#tokio-main-宏" class="headerlink" title="tokio::main 宏"></a>tokio::main 宏</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokio-macros/src/lib.rs</span></span><br><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>(args: TokenStream, item: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    entry::<span class="title function_ invoke__">main</span>(args.<span class="title function_ invoke__">into</span>(), item.<span class="title function_ invoke__">into</span>(), <span class="literal">true</span>).<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tokio-macros/src/entry.rs</span></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">main</span>(args: TokenStream, item: TokenStream, rt_multi_thread: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="comment">// If any of the steps for this macro fail, we still want to expand to an item that is as close</span></span><br><span class="line">    <span class="comment">// to the expected output as possible. This helps out IDEs such that completions and other</span></span><br><span class="line">    <span class="comment">// related features keep working.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span>: ItemFn = <span class="keyword">match</span> syn::<span class="title function_ invoke__">parse2</span>(item.<span class="title function_ invoke__">clone</span>()) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(it) =&gt; it,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">token_stream_with_error</span>(item, e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = <span class="keyword">if</span> input.sig.ident == <span class="string">&quot;main&quot;</span> &amp;&amp; !input.sig.inputs.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msg</span> = <span class="string">&quot;the main function cannot accept arguments&quot;</span>;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(syn::Error::<span class="title function_ invoke__">new_spanned</span>(&amp;input.sig.ident, msg))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AttributeArgs::parse_terminated</span><br><span class="line">            .<span class="title function_ invoke__">parse2</span>(args)</span><br><span class="line">            .<span class="title function_ invoke__">and_then</span>(|args| <span class="title function_ invoke__">build_config</span>(&amp;input, args, <span class="literal">false</span>, rt_multi_thread))</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> config &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(config) =&gt; <span class="title function_ invoke__">parse_knobs</span>(input, <span class="literal">false</span>, config),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">token_stream_with_error</span>(<span class="title function_ invoke__">parse_knobs</span>(input, <span class="literal">false</span>, DEFAULT_ERROR_CONFIG), e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的代码都先不用管，直接看解析配置。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokio-macros/src/entry.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_knobs</span>(<span class="keyword">mut</span> input: ItemFn, is_test: <span class="type">bool</span>, config: FinalConfig) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    input.sig.asyncness = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If type mismatch occurs, the current rustc points to the last statement.</span></span><br><span class="line">    <span class="keyword">let</span> (last_stmt_start_span, last_stmt_end_span) = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">last_stmt</span> = input.stmts.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">unwrap_or_default</span>().<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// `Span` on stable Rust has a limitation that only points to the first</span></span><br><span class="line">        <span class="comment">// token, not the whole tokens. We can work around this limitation by</span></span><br><span class="line">        <span class="comment">// using the first/last span of the tokens like</span></span><br><span class="line">        <span class="comment">// `syn::Error::new_spanned` does.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">start</span> = last_stmt.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">map_or_else</span>(Span::call_site, |t| t.<span class="title function_ invoke__">span</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">end</span> = last_stmt.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">map_or</span>(start, |t| t.<span class="title function_ invoke__">span</span>());</span><br><span class="line">        (start, end)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">crate_path</span> = config</span><br><span class="line">        .crate_name</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(ToTokens::into_token_stream)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap_or_else</span>(|| Ident::<span class="title function_ invoke__">new</span>(<span class="string">&quot;tokio&quot;</span>, last_stmt_start_span).<span class="title function_ invoke__">into_token_stream</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rt</span> = <span class="keyword">match</span> config.flavor &#123;</span><br><span class="line">        RuntimeFlavor::CurrentThread =&gt; quote_spanned! &#123;last_stmt_start_span=&gt;</span><br><span class="line">            #crate_path::runtime::Builder::<span class="title function_ invoke__">new_current_thread</span>()</span><br><span class="line">        &#125;,</span><br><span class="line">        RuntimeFlavor::Threaded =&gt; quote_spanned! &#123;last_stmt_start_span=&gt;</span><br><span class="line">            #crate_path::runtime::Builder::<span class="title function_ invoke__">new_multi_thread</span>()</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = config.worker_threads &#123;</span><br><span class="line">        rt = quote_spanned! &#123;last_stmt_start_span=&gt; #rt.<span class="title function_ invoke__">worker_threads</span>(#v) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = config.start_paused &#123;</span><br><span class="line">        rt = quote_spanned! &#123;last_stmt_start_span=&gt; #rt.<span class="title function_ invoke__">start_paused</span>(#v) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(v) = config.unhandled_panic &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">unhandled_panic</span> = v.<span class="title function_ invoke__">into_tokens</span>(&amp;crate_path);</span><br><span class="line">        rt = quote_spanned! &#123;last_stmt_start_span=&gt; #rt.<span class="title function_ invoke__">unhandled_panic</span>(#unhandled_panic) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">generated_attrs</span> = <span class="keyword">if</span> is_test &#123;</span><br><span class="line">        quote! &#123;</span><br><span class="line">            <span class="meta">#[::core::prelude::v1::test]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quote! &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">body_ident</span> = quote! &#123; body &#125;;</span><br><span class="line">    <span class="comment">// This explicit `return` is intentional. See tokio-rs/tokio#4636</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">last_block</span> = quote_spanned! &#123;last_stmt_end_span=&gt;</span><br><span class="line">        <span class="meta">#[allow(clippy::expect_used, clippy::diverging_sub_expression, clippy::needless_return)]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> #rt</span><br><span class="line">                .<span class="title function_ invoke__">enable_all</span>()</span><br><span class="line">                .<span class="title function_ invoke__">build</span>()</span><br><span class="line">                .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed building the Runtime&quot;</span>)</span><br><span class="line">                .<span class="title function_ invoke__">block_on</span>(#body_ident);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">body</span> = input.<span class="title function_ invoke__">body</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For test functions pin the body to the stack and use `Pin&lt;&amp;mut dyn</span></span><br><span class="line">    <span class="comment">// Future&gt;` to reduce the amount of `Runtime::block_on` (and related</span></span><br><span class="line">    <span class="comment">// functions) copies we generate during compilation due to the generic</span></span><br><span class="line">    <span class="comment">// parameter `F` (the future to block on). This could have an impact on</span></span><br><span class="line">    <span class="comment">// performance, but because it&#x27;s only for testing it&#x27;s unlikely to be very</span></span><br><span class="line">    <span class="comment">// large.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We don&#x27;t do this for the main function as it should only be used once so</span></span><br><span class="line">    <span class="comment">// there will be no benefit.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">body</span> = <span class="keyword">if</span> is_test &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">output_type</span> = <span class="keyword">match</span> &amp;input.sig.output &#123;</span><br><span class="line">            <span class="comment">// For functions with no return value syn doesn&#x27;t print anything,</span></span><br><span class="line">            <span class="comment">// but that doesn&#x27;t work as `Output` for our boxed `Future`, so</span></span><br><span class="line">            <span class="comment">// default to `()` (the same type as the function output).</span></span><br><span class="line">            syn::ReturnType::<span class="built_in">Default</span> =&gt; quote! &#123; () &#125;,</span><br><span class="line">            syn::ReturnType::<span class="title function_ invoke__">Type</span>(_, ret_type) =&gt; quote! &#123; #ret_type &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        quote! &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">body</span> = <span class="keyword">async</span> #body;</span><br><span class="line">            #crate_path::pin!(body);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">body</span>: ::core::pin::Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> ::core::future::Future&lt;Output = #output_type&gt;&gt; = body;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quote! &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">body</span> = <span class="keyword">async</span> #body;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    input.<span class="title function_ invoke__">into_tokens</span>(generated_attrs, body, last_block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里值得注意的有两点：</p>
<ol>
<li>builder 创建单线程或多线程的 runtime</li>
<li>builder build 创建之后会 block 在 我们写的 main 函数的代码。</li>
</ol>
<p>开头的代码相当于</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">runtime::Builder::<span class="title function_ invoke__">new_multi_thread</span>()</span><br><span class="line">                .<span class="title function_ invoke__">enable_all</span>()</span><br><span class="line">                .<span class="title function_ invoke__">build</span>()</span><br><span class="line">                .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed building the Runtime&quot;</span>)</span><br><span class="line">                .<span class="title function_ invoke__">block_on</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">file</span> = OpenOptions::<span class="title function_ invoke__">new</span>()</span><br><span class="line">                        .<span class="title function_ invoke__">read</span>(<span class="literal">true</span>)</span><br><span class="line">                        .<span class="title function_ invoke__">open</span>(<span class="string">&quot;foo.txt&quot;</span>)</span><br><span class="line">                        .<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="multi-thread-builder-build"><a href="#multi-thread-builder-build" class="headerlink" title="multi thread builder build"></a>multi thread builder build</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokio/src/runtime/builder.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_multi_thread</span>() <span class="punctuation">-&gt;</span> Builder &#123;</span><br><span class="line">        <span class="comment">// The number `61` is fairly arbitrary. I believe this value was copied from golang.</span></span><br><span class="line">        Builder::<span class="title function_ invoke__">new</span>(Kind::MultiThread, <span class="number">61</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">build</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;Runtime&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> &amp;<span class="keyword">self</span>.kind &#123;</span><br><span class="line">            Kind::CurrentThread =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">build_current_thread_runtime</span>(),</span><br><span class="line">            <span class="meta">#[cfg(feature = <span class="string">&quot;rt-multi-thread&quot;</span>)]</span></span><br><span class="line">            Kind::MultiThread =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">build_threaded_runtime</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokio/src/runtime/builder.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build_threaded_runtime</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;Runtime&gt; &#123;</span><br><span class="line">            <span class="keyword">use</span> crate::loom::sys::num_cpus;</span><br><span class="line">            <span class="keyword">use</span> crate::runtime::&#123;Config, runtime::Scheduler&#125;;</span><br><span class="line">            <span class="keyword">use</span> crate::runtime::scheduler::&#123;<span class="keyword">self</span>, MultiThread&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">worker_threads</span> = <span class="keyword">self</span>.worker_threads.<span class="title function_ invoke__">unwrap_or_else</span>(num_cpus);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> (driver, driver_handle) = driver::Driver::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">get_cfg</span>())?;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the blocking pool</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">blocking_pool</span> =</span><br><span class="line">                blocking::<span class="title function_ invoke__">create_blocking_pool</span>(<span class="keyword">self</span>, <span class="keyword">self</span>.max_blocking_threads + worker_threads);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">blocking_spawner</span> = blocking_pool.<span class="title function_ invoke__">spawner</span>().<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Generate a rng seed for this runtime.</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">seed_generator_1</span> = <span class="keyword">self</span>.seed_generator.<span class="title function_ invoke__">next_generator</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">seed_generator_2</span> = <span class="keyword">self</span>.seed_generator.<span class="title function_ invoke__">next_generator</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> (scheduler, handle, launch) = MultiThread::<span class="title function_ invoke__">new</span>(</span><br><span class="line">                worker_threads,</span><br><span class="line">                driver,</span><br><span class="line">                driver_handle,</span><br><span class="line">                blocking_spawner,</span><br><span class="line">                seed_generator_2,</span><br><span class="line">                Config &#123;</span><br><span class="line">                    before_park: <span class="keyword">self</span>.before_park.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    after_unpark: <span class="keyword">self</span>.after_unpark.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    before_spawn: <span class="keyword">self</span>.before_spawn.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    <span class="meta">#[cfg(tokio_unstable)]</span></span><br><span class="line">                    before_poll: <span class="keyword">self</span>.before_poll.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    <span class="meta">#[cfg(tokio_unstable)]</span></span><br><span class="line">                    after_poll: <span class="keyword">self</span>.after_poll.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    after_termination: <span class="keyword">self</span>.after_termination.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    global_queue_interval: <span class="keyword">self</span>.global_queue_interval,</span><br><span class="line">                    event_interval: <span class="keyword">self</span>.event_interval,</span><br><span class="line">                    <span class="meta">#[cfg(tokio_unstable)]</span></span><br><span class="line">                    unhandled_panic: <span class="keyword">self</span>.unhandled_panic.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">                    disable_lifo_slot: <span class="keyword">self</span>.disable_lifo_slot,</span><br><span class="line">                    seed_generator: seed_generator_1,</span><br><span class="line">                    metrics_poll_count_histogram: <span class="keyword">self</span>.<span class="title function_ invoke__">metrics_poll_count_histogram_builder</span>(),</span><br><span class="line">                &#125;,</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">handle</span> = Handle &#123; inner: scheduler::Handle::<span class="title function_ invoke__">MultiThread</span>(handle) &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Spawn the thread pool workers</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">_enter</span> = handle.<span class="title function_ invoke__">enter</span>();</span><br><span class="line">            launch.<span class="title function_ invoke__">launch</span>();</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(Runtime::<span class="title function_ invoke__">from_parts</span>(Scheduler::<span class="title function_ invoke__">MultiThread</span>(scheduler), handle, blocking_pool))</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认创建 CPU 数量的 Worker。</p>
<h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Launch</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">launch</span>(<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">worker</span> <span class="keyword">in</span> <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">drain</span>(..) &#123;</span><br><span class="line">            runtime::<span class="title function_ invoke__">spawn_blocking</span>(<span class="keyword">move</span> || <span class="title function_ invoke__">run</span>(worker));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runtime::spawn_blocking 的内部实现大致就是启动线程，处理线程的队列任务。目前每个线程的队列任务就是 <code>run(worker)</code>。</p>
<h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokio/src/runtime/scheduler/multi_thread/worker.rs</span></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">super</span>) <span class="keyword">struct</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">    <span class="comment">/// Reference to scheduler&#x27;s handle</span></span><br><span class="line">    handle: Arc&lt;Handle&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Index holding this worker&#x27;s remote state</span></span><br><span class="line">    index: <span class="type">usize</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Used to hand-off a worker&#x27;s core to another thread.</span></span><br><span class="line">    core: AtomicCell&lt;Core&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core"><a href="#core" class="headerlink" title="core"></a>core</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokio/src/runtime/scheduler/multi_thread/worker.rs</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Core</span> &#123;</span><br><span class="line">    <span class="comment">/// When a task is scheduled from a worker, it is stored in this slot. The</span></span><br><span class="line">    <span class="comment">/// worker will check this slot for a task **before** checking the run</span></span><br><span class="line">    <span class="comment">/// queue. This effectively results in the **last** scheduled task to be run</span></span><br><span class="line">    <span class="comment">/// next (LIFO). This is an optimization for improving locality which</span></span><br><span class="line">    <span class="comment">/// benefits message passing patterns and helps to reduce latency.</span></span><br><span class="line">    lifo_slot: <span class="type">Option</span>&lt;Notified&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// When `true`, locally scheduled tasks go to the LIFO slot. When `false`,</span></span><br><span class="line">    <span class="comment">/// they go to the back of the `run_queue`.</span></span><br><span class="line">    lifo_enabled: <span class="type">bool</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The worker-local run queue.</span></span><br><span class="line">    run_queue: queue::Local&lt;Arc&lt;Handle&gt;&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<a href="/2025/06/17/tokio-rt-spawn/#core" title="tokio runtime -- spawn">上一章</a>也提到了</p>
<h3 id="run-worker"><a href="#run-worker" class="headerlink" title="run worker"></a>run worker</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokio/src/runtime/scheduler/multi_thread/worker.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(worker: Arc&lt;Worker&gt;) &#123;</span><br><span class="line">    <span class="meta">#[allow(dead_code)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">AbortOnPanic</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">AbortOnPanic</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> std::thread::<span class="title function_ invoke__">panicking</span>() &#123;</span><br><span class="line">                <span class="built_in">eprintln!</span>(<span class="string">&quot;worker thread panicking; aborting process&quot;</span>);</span><br><span class="line">                std::process::<span class="title function_ invoke__">abort</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Catching panics on worker threads in tests is quite tricky. Instead, when</span></span><br><span class="line">    <span class="comment">// debug assertions are enabled, we just abort the process.</span></span><br><span class="line">    <span class="meta">#[cfg(debug_assertions)]</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_abort_on_panic</span> = AbortOnPanic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire a core. If this fails, then another thread is running this</span></span><br><span class="line">    <span class="comment">// worker and there is nothing further to do.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">core</span> = <span class="keyword">match</span> worker.core.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(core) =&gt; core,</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="keyword">return</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    worker.handle.shared.worker_metrics[worker.index].<span class="title function_ invoke__">set_thread_id</span>(thread::<span class="title function_ invoke__">current</span>().<span class="title function_ invoke__">id</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = scheduler::Handle::<span class="title function_ invoke__">MultiThread</span>(worker.handle.<span class="title function_ invoke__">clone</span>());</span><br><span class="line"></span><br><span class="line">    crate::runtime::context::<span class="title function_ invoke__">enter_runtime</span>(&amp;handle, <span class="literal">true</span>, |_| &#123;</span><br><span class="line">        <span class="comment">// Set the worker context.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cx</span> = scheduler::Context::<span class="title function_ invoke__">MultiThread</span>(Context &#123;</span><br><span class="line">            worker,</span><br><span class="line">            core: RefCell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line">            defer: Defer::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        context::<span class="title function_ invoke__">set_scheduler</span>(&amp;cx, || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">cx</span> = cx.<span class="title function_ invoke__">expect_multi_thread</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This should always be an error. It only returns a `Result` to support</span></span><br><span class="line">            <span class="comment">// using `?` to short circuit.</span></span><br><span class="line">            <span class="built_in">assert!</span>(cx.<span class="title function_ invoke__">run</span>(core).<span class="title function_ invoke__">is_err</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if there are any deferred tasks to notify. This can happen when</span></span><br><span class="line">            <span class="comment">// the worker core is lost due to `block_in_place()` being called from</span></span><br><span class="line">            <span class="comment">// within the task.</span></span><br><span class="line">            cx.defer.<span class="title function_ invoke__">wake</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokio/src/runtime/context/runtime.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">enter_runtime</span>&lt;F, R&gt;(handle: &amp;scheduler::Handle, allow_block_in_place: <span class="type">bool</span>, f: F) <span class="punctuation">-&gt;</span> R</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">maybe_guard</span> = CONTEXT.<span class="title function_ invoke__">with</span>(|c| &#123;</span><br><span class="line">        <span class="keyword">if</span> c.runtime.<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">is_entered</span>() &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Set the entered flag</span></span><br><span class="line">            c.runtime.<span class="title function_ invoke__">set</span>(EnterRuntime::Entered &#123;</span><br><span class="line">                allow_block_in_place,</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Generate a new seed</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rng_seed</span> = handle.<span class="title function_ invoke__">seed_generator</span>().<span class="title function_ invoke__">next_seed</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Swap the RNG seed</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">rng</span> = c.rng.<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">unwrap_or_else</span>(FastRand::new);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">old_seed</span> = rng.<span class="title function_ invoke__">replace_seed</span>(rng_seed);</span><br><span class="line">            c.rng.<span class="title function_ invoke__">set</span>(<span class="title function_ invoke__">Some</span>(rng));</span><br><span class="line"></span><br><span class="line">            <span class="title function_ invoke__">Some</span>(EnterRuntimeGuard &#123;</span><br><span class="line">                blocking: BlockingRegionGuard::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                handle: c.<span class="title function_ invoke__">set_current</span>(handle),</span><br><span class="line">                old_seed,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">mut</span> guard) = maybe_guard &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">f</span>(&amp;<span class="keyword">mut</span> guard.blocking);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokio/src/runtime/context.rs</span></span><br><span class="line">tokio_thread_local! &#123;</span><br><span class="line">    <span class="keyword">static</span> CONTEXT: Context = <span class="keyword">const</span> &#123;</span><br><span class="line">        Context &#123;</span><br><span class="line">            <span class="meta">#[cfg(feature = <span class="string">&quot;rt&quot;</span>)]</span></span><br><span class="line">            thread_id: Cell::<span class="title function_ invoke__">new</span>(<span class="literal">None</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tracks the current runtime handle to use when spawning,</span></span><br><span class="line">            <span class="comment">// accessing drivers, etc...</span></span><br><span class="line">            <span class="meta">#[cfg(feature = <span class="string">&quot;rt&quot;</span>)]</span></span><br><span class="line">            current: current::HandleCell::<span class="title function_ invoke__">new</span>(),</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tracks the current scheduler internal context</span></span><br><span class="line">            <span class="meta">#[cfg(feature = <span class="string">&quot;rt&quot;</span>)]</span></span><br><span class="line">            scheduler: Scoped::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了当前线程的 <code>Thread Context</code>，设置它的 <code>Scheduler</code>（worker.handle.clone）。<br>之后创建 <code>Worker Context</code>（参见<a href="/2025/06/17/tokio-rt-spawn/#context" title="tokio runtime -- spawn">上一章</a>）。最后在 <code>Worker Context</code> 上通过 <code>cx.run(core)</code> 执行任务。</p>
<h3 id="run-core"><a href="#run-core" class="headerlink" title="run core"></a>run core</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokio/src/runtime/scheduler/multi_thread/worker.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>, <span class="keyword">mut</span> core: <span class="type">Box</span>&lt;Core&gt;) <span class="punctuation">-&gt;</span> RunResult &#123;</span><br><span class="line">        <span class="comment">// Reset `lifo_enabled` here in case the core was previously stolen from</span></span><br><span class="line">        <span class="comment">// a task that had the LIFO slot disabled.</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">reset_lifo_enabled</span>(&amp;<span class="keyword">mut</span> core);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start as &quot;processing&quot; tasks as polling tasks from the local queue</span></span><br><span class="line">        <span class="comment">// will be one of the first things we do.</span></span><br><span class="line">        core.stats.<span class="title function_ invoke__">start_processing_scheduled_tasks</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> !core.is_shutdown &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">assert_lifo_enabled_is_correct</span>(&amp;core);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> core.is_traced &#123;</span><br><span class="line">                core = <span class="keyword">self</span>.worker.handle.<span class="title function_ invoke__">trace_core</span>(core);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Increment the tick</span></span><br><span class="line">            core.<span class="title function_ invoke__">tick</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Run maintenance, if needed</span></span><br><span class="line">            core = <span class="keyword">self</span>.<span class="title function_ invoke__">maintenance</span>(core);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// First, check work available to the current worker.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = core.<span class="title function_ invoke__">next_task</span>(&amp;<span class="keyword">self</span>.worker) &#123;</span><br><span class="line">                core = <span class="keyword">self</span>.<span class="title function_ invoke__">run_task</span>(task, core)?;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We consumed all work in the queues and will start searching for work.</span></span><br><span class="line">            core.stats.<span class="title function_ invoke__">end_processing_scheduled_tasks</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// There is no more **local** work to process, try to steal work</span></span><br><span class="line">            <span class="comment">// from other workers.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = core.<span class="title function_ invoke__">steal_work</span>(&amp;<span class="keyword">self</span>.worker) &#123;</span><br><span class="line">                <span class="comment">// Found work, switch back to processing</span></span><br><span class="line">                core.stats.<span class="title function_ invoke__">start_processing_scheduled_tasks</span>();</span><br><span class="line">                core = <span class="keyword">self</span>.<span class="title function_ invoke__">run_task</span>(task, core)?;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Wait for work</span></span><br><span class="line">                core = <span class="keyword">if</span> !<span class="keyword">self</span>.defer.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">                    <span class="keyword">self</span>.<span class="title function_ invoke__">park_timeout</span>(core, <span class="title function_ invoke__">Some</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">0</span>)))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">self</span>.<span class="title function_ invoke__">park</span>(core)</span><br><span class="line">                &#125;;</span><br><span class="line">                core.stats.<span class="title function_ invoke__">start_processing_scheduled_tasks</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        core.<span class="title function_ invoke__">pre_shutdown</span>(&amp;<span class="keyword">self</span>.worker);</span><br><span class="line">        <span class="comment">// Signal shutdown</span></span><br><span class="line">        <span class="keyword">self</span>.worker.handle.<span class="title function_ invoke__">shutdown_core</span>(core);</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见的做法，只要不 Shutdown，就循环获取 Task，没有 Task 就挂起转入 Idle。</p>
<p>获取Task的流程：</p>
<ol>
<li>get next task</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Core</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next_task</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, worker: &amp;Worker) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Notified&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.tick % <span class="keyword">self</span>.global_queue_interval == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// Update the global queue interval, if needed</span></span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">tune_global_queue_interval</span>(worker);</span><br><span class="line"></span><br><span class="line">            worker</span><br><span class="line">                .handle</span><br><span class="line">                .<span class="title function_ invoke__">next_remote_task</span>()</span><br><span class="line">                .<span class="title function_ invoke__">or_else</span>(|| <span class="keyword">self</span>.<span class="title function_ invoke__">next_local_task</span>())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">maybe_task</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">next_local_task</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> maybe_task.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> maybe_task;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> worker.<span class="title function_ invoke__">inject</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Other threads can only **remove** tasks from the current worker&#x27;s</span></span><br><span class="line">            <span class="comment">// `run_queue`. So, we can be confident that by the time we call</span></span><br><span class="line">            <span class="comment">// `run_queue.push_back` below, there will be *at least* `cap`</span></span><br><span class="line">            <span class="comment">// available slots in the queue.</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">cap</span> = <span class="type">usize</span>::<span class="title function_ invoke__">min</span>(</span><br><span class="line">                <span class="keyword">self</span>.run_queue.<span class="title function_ invoke__">remaining_slots</span>(),</span><br><span class="line">                <span class="keyword">self</span>.run_queue.<span class="title function_ invoke__">max_capacity</span>() / <span class="number">2</span>,</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The worker is currently idle, pull a batch of work from the</span></span><br><span class="line">            <span class="comment">// injection queue. We don&#x27;t want to pull *all* the work so other</span></span><br><span class="line">            <span class="comment">// workers can also get some.</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">n</span> = <span class="type">usize</span>::<span class="title function_ invoke__">min</span>(</span><br><span class="line">                worker.<span class="title function_ invoke__">inject</span>().<span class="title function_ invoke__">len</span>() / worker.handle.shared.remotes.<span class="title function_ invoke__">len</span>() + <span class="number">1</span>,</span><br><span class="line">                cap,</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Take at least one task since the first task is returned directly</span></span><br><span class="line">            <span class="comment">// and not pushed onto the local queue.</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">n</span> = <span class="type">usize</span>::<span class="title function_ invoke__">max</span>(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">synced</span> = worker.handle.shared.synced.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">            <span class="comment">// safety: passing in the correct `inject::Synced`.</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tasks</span> = <span class="keyword">unsafe</span> &#123; worker.<span class="title function_ invoke__">inject</span>().<span class="title function_ invoke__">pop_n</span>(&amp;<span class="keyword">mut</span> synced.inject, n) &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Pop the first task to return immediately</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">ret</span> = tasks.<span class="title function_ invoke__">next</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Push the rest of the on the run queue</span></span><br><span class="line">            <span class="keyword">self</span>.run_queue.<span class="title function_ invoke__">push_back</span>(tasks);</span><br><span class="line"></span><br><span class="line">            ret</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next_local_task</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Notified&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.lifo_slot.<span class="title function_ invoke__">take</span>().<span class="title function_ invoke__">or_else</span>(|| <span class="keyword">self</span>.run_queue.<span class="title function_ invoke__">pop</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每隔一段时间从全局队列获取任务</li>
<li>优先从 LIFO slot 获取任务</li>
<li>从本地队列获取任务</li>
<li>如果本地队列没有可取的 Task，从全局队列获取本地能够容纳的 Tasks 插入本地队列，拿出第一个。</li>
</ul>
<ol start="2">
<li>steal task</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/scheduler/multi_thread/worker.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Core</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">steal_work</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, worker: &amp;Worker) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Notified&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.<span class="title function_ invoke__">transition_to_searching</span>(worker) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num</span> = worker.handle.shared.remotes.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="comment">// Start from a random worker</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">start</span> = <span class="keyword">self</span>.rand.<span class="title function_ invoke__">fastrand_n</span>(num <span class="keyword">as</span> <span class="type">u32</span>) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..num &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">i</span> = (start + i) % num;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don&#x27;t steal from ourself! We know we don&#x27;t have work.</span></span><br><span class="line">            <span class="keyword">if</span> i == worker.index &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">target</span> = &amp;worker.handle.shared.remotes[i];</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(task) = target</span><br><span class="line">                .steal</span><br><span class="line">                .<span class="title function_ invoke__">steal_into</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.run_queue, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.stats)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fallback on checking the global queue</span></span><br><span class="line">        worker.handle.<span class="title function_ invoke__">next_remote_task</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从其他 Worker 里随机挑选一个偷取任务，避免竞争。并且 <code>transition_to_searching</code> 会开始一个计数，当这个计数增长到 worker 数目的一半时，会被暂时排除出小偷家族。另外 <code>steal_into</code> 内部也会通过原子读取比对，来确保同时偷取发生时，只有一个能成功。（具体代码就不贴了）</p>
<h3 id="run-task"><a href="#run-task" class="headerlink" title="run task"></a>run task</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tokio/src/runtime/scheduler/multi_thread/worker.rs</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run_task</span>(&amp;<span class="keyword">self</span>, task: Notified, <span class="keyword">mut</span> core: <span class="type">Box</span>&lt;Core&gt;) <span class="punctuation">-&gt;</span> RunResult &#123;</span><br><span class="line">        <span class="meta">#[cfg(tokio_unstable)]</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">task_id</span> = task.<span class="title function_ invoke__">task_id</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">task</span> = <span class="keyword">self</span>.worker.handle.shared.owned.<span class="title function_ invoke__">assert_owner</span>(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the worker is not in the **searching** state. This enables</span></span><br><span class="line">        <span class="comment">// another idle worker to try to steal work.</span></span><br><span class="line">        core.<span class="title function_ invoke__">transition_from_searching</span>(&amp;<span class="keyword">self</span>.worker);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">assert_lifo_enabled_is_correct</span>(&amp;core);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Measure the poll start time. Note that we may end up polling other</span></span><br><span class="line">        <span class="comment">// tasks under this measurement. In this case, the tasks came from the</span></span><br><span class="line">        <span class="comment">// LIFO slot and are considered part of the current task for scheduling</span></span><br><span class="line">        <span class="comment">// purposes. These tasks inherent the &quot;parent&quot;&#x27;s limits.</span></span><br><span class="line">        core.stats.<span class="title function_ invoke__">start_poll</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make the core available to the runtime context</span></span><br><span class="line">        *<span class="keyword">self</span>.core.<span class="title function_ invoke__">borrow_mut</span>() = <span class="title function_ invoke__">Some</span>(core);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the task</span></span><br><span class="line">        coop::<span class="title function_ invoke__">budget</span>(|| &#123;</span><br><span class="line">            <span class="comment">// Unlike the poll time above, poll start callback is attached to the task id,</span></span><br><span class="line">            <span class="comment">// so it is tightly associated with the actual poll invocation.</span></span><br><span class="line">            <span class="meta">#[cfg(tokio_unstable)]</span></span><br><span class="line">            <span class="keyword">self</span>.worker.handle.task_hooks.<span class="title function_ invoke__">poll_start_callback</span>(task_id);</span><br><span class="line"></span><br><span class="line">            task.<span class="title function_ invoke__">run</span>();</span><br><span class="line"></span><br><span class="line">            <span class="meta">#[cfg(tokio_unstable)]</span></span><br><span class="line">            <span class="keyword">self</span>.worker.handle.task_hooks.<span class="title function_ invoke__">poll_stop_callback</span>(task_id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lifo_polls</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// As long as there is budget remaining and a task exists in the</span></span><br><span class="line">            <span class="comment">// `lifo_slot`, then keep running.</span></span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="comment">// Check if we still have the core. If not, the core was stolen</span></span><br><span class="line">                <span class="comment">// by another worker.</span></span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">core</span> = <span class="keyword">match</span> <span class="keyword">self</span>.core.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(core) =&gt; core,</span><br><span class="line">                    <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                        <span class="comment">// In this case, we cannot call `reset_lifo_enabled()`</span></span><br><span class="line">                        <span class="comment">// because the core was stolen. The stealer will handle</span></span><br><span class="line">                        <span class="comment">// that at the top of `Context::run`</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check for a task in the LIFO slot</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">task</span> = <span class="keyword">match</span> core.lifo_slot.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(task) =&gt; task,</span><br><span class="line">                    <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                        <span class="keyword">self</span>.<span class="title function_ invoke__">reset_lifo_enabled</span>(&amp;<span class="keyword">mut</span> core);</span><br><span class="line">                        core.stats.<span class="title function_ invoke__">end_poll</span>();</span><br><span class="line">                        <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(core);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> !coop::<span class="title function_ invoke__">has_budget_remaining</span>() &#123;</span><br><span class="line">                    core.stats.<span class="title function_ invoke__">end_poll</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Not enough budget left to run the LIFO task, push it to</span></span><br><span class="line">                    <span class="comment">// the back of the queue and return.</span></span><br><span class="line">                    core.run_queue.<span class="title function_ invoke__">push_back_or_overflow</span>(</span><br><span class="line">                        task,</span><br><span class="line">                        &amp;*<span class="keyword">self</span>.worker.handle,</span><br><span class="line">                        &amp;<span class="keyword">mut</span> core.stats,</span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">// If we hit this point, the LIFO slot should be enabled.</span></span><br><span class="line">                    <span class="comment">// There is no need to reset it.</span></span><br><span class="line">                    <span class="built_in">debug_assert!</span>(core.lifo_enabled);</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(core);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Track that we are about to run a task from the LIFO slot.</span></span><br><span class="line">                lifo_polls += <span class="number">1</span>;</span><br><span class="line">                super::counters::<span class="title function_ invoke__">inc_lifo_schedules</span>();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Disable the LIFO slot if we reach our limit</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// In ping-ping style workloads where task A notifies task B,</span></span><br><span class="line">                <span class="comment">// which notifies task A again, continuously prioritizing the</span></span><br><span class="line">                <span class="comment">// LIFO slot can cause starvation as these two tasks will</span></span><br><span class="line">                <span class="comment">// repeatedly schedule the other. To mitigate this, we limit the</span></span><br><span class="line">                <span class="comment">// number of times the LIFO slot is prioritized.</span></span><br><span class="line">                <span class="keyword">if</span> lifo_polls &gt;= MAX_LIFO_POLLS_PER_TICK &#123;</span><br><span class="line">                    core.lifo_enabled = <span class="literal">false</span>;</span><br><span class="line">                    super::counters::<span class="title function_ invoke__">inc_lifo_capped</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Run the LIFO task, then loop</span></span><br><span class="line">                *<span class="keyword">self</span>.core.<span class="title function_ invoke__">borrow_mut</span>() = <span class="title function_ invoke__">Some</span>(core);</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">task</span> = <span class="keyword">self</span>.worker.handle.shared.owned.<span class="title function_ invoke__">assert_owner</span>(task);</span><br><span class="line"></span><br><span class="line">                <span class="meta">#[cfg(tokio_unstable)]</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">task_id</span> = task.<span class="title function_ invoke__">task_id</span>();</span><br><span class="line"></span><br><span class="line">                <span class="meta">#[cfg(tokio_unstable)]</span></span><br><span class="line">                <span class="keyword">self</span>.worker.handle.task_hooks.<span class="title function_ invoke__">poll_start_callback</span>(task_id);</span><br><span class="line"></span><br><span class="line">                task.<span class="title function_ invoke__">run</span>();</span><br><span class="line"></span><br><span class="line">                <span class="meta">#[cfg(tokio_unstable)]</span></span><br><span class="line">                <span class="keyword">self</span>.worker.handle.task_hooks.<span class="title function_ invoke__">poll_stop_callback</span>(task_id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要理解 <code>task.run()</code> 做了什么需要另一写篇<a href="/2025/06/19/tokio-rt-task/" title="tokio runtime -- task">文章</a>才能说清楚。暂且认为是运行我们写的 async 代码。<code>coop::budget</code> 引入了时间片概念。task 开始运行会分配时间片，当 task 挂起时会消耗时间片。如果 task 通过 slot 重新唤起，发现时间片不够用了，会重新排队。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/null">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#tokio-main-%E5%AE%8F"><span class="toc-number">1.</span> <span class="toc-text">tokio::main 宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#multi-thread-builder-build"><span class="toc-number">2.</span> <span class="toc-text">multi thread builder build</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#launch"><span class="toc-number">2.1.</span> <span class="toc-text">launch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#worker"><span class="toc-number">2.2.</span> <span class="toc-text">worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#core"><span class="toc-number">2.3.</span> <span class="toc-text">core</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run-worker"><span class="toc-number">2.4.</span> <span class="toc-text">run worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run-core"><span class="toc-number">2.5.</span> <span class="toc-text">run core</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#run-task"><span class="toc-number">2.6.</span> <span class="toc-text">run task</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://zhaosima.github.io/2025/06/17/tokio-rt-main/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&text=tokio runtime -- main macro"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&title=tokio runtime -- main macro"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&is_video=false&description=tokio runtime -- main macro"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=tokio runtime -- main macro&body=Check out this article: https://zhaosima.github.io/2025/06/17/tokio-rt-main/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&title=tokio runtime -- main macro"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&title=tokio runtime -- main macro"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&title=tokio runtime -- main macro"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&title=tokio runtime -- main macro"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&name=tokio runtime -- main macro&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://zhaosima.github.io/2025/06/17/tokio-rt-main/&t=tokio runtime -- main macro"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2025
    WindFlow
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/null">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
